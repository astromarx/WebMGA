[{"/home/padrino-eduardo/Desktop/webmga/src/index.js":"1","/home/padrino-eduardo/Desktop/webmga/src/App.js":"2","/home/padrino-eduardo/Desktop/webmga/src/Controller.js":"3","/home/padrino-eduardo/Desktop/webmga/src/View/Top.js":"4","/home/padrino-eduardo/Desktop/webmga/src/View/Side.js":"5","/home/padrino-eduardo/Desktop/webmga/src/Model/Model.js":"6","/home/padrino-eduardo/Desktop/webmga/src/Model/Light.js":"7","/home/padrino-eduardo/Desktop/webmga/src/View/SubMenus.js":"8","/home/padrino-eduardo/Desktop/webmga/src/Model/Shapes.js":"9","/home/padrino-eduardo/Desktop/webmga/src/View/Tools.js":"10","/home/padrino-eduardo/Desktop/webmga/src/View/View.js":"11","/home/padrino-eduardo/Desktop/webmga/src/Model/Set.js":"12","/home/padrino-eduardo/Desktop/webmga/src/Model/Parameters.js":"13","/home/padrino-eduardo/Desktop/webmga/src/Model/Tools.js":"14"},{"size":198,"mtime":1609107771761,"results":"15","hashOfConfig":"16"},{"size":928,"mtime":1615571603864,"results":"17","hashOfConfig":"16"},{"size":8464,"mtime":1616635963534,"results":"18","hashOfConfig":"16"},{"size":11176,"mtime":1616614653827,"results":"19","hashOfConfig":"16"},{"size":6049,"mtime":1616607619609,"results":"20","hashOfConfig":"16"},{"size":12912,"mtime":1616633745406,"results":"21","hashOfConfig":"16"},{"size":1375,"mtime":1615937179706,"results":"22","hashOfConfig":"16"},{"size":31803,"mtime":1616627890763,"results":"23","hashOfConfig":"16"},{"size":23961,"mtime":1615568308370,"results":"24","hashOfConfig":"16"},{"size":6291,"mtime":1615495857203,"results":"25","hashOfConfig":"16"},{"size":6547,"mtime":1616633018276,"results":"26","hashOfConfig":"16"},{"size":12902,"mtime":1616635209709,"results":"27","hashOfConfig":"16"},{"size":655,"mtime":1615574359931,"results":"28","hashOfConfig":"16"},{"size":4837,"mtime":1616606101669,"results":"29","hashOfConfig":"16"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},"qy2pz8",{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"35","messages":"36","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"37","messages":"38","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"39","usedDeprecatedRules":"32"},{"filePath":"40","messages":"41","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"44","usedDeprecatedRules":"32"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"49","usedDeprecatedRules":"32"},{"filePath":"50","messages":"51","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"52","messages":"53","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"54","messages":"55","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"56","messages":"57","errorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"58","usedDeprecatedRules":"32"},{"filePath":"59","messages":"60","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},{"filePath":"61","messages":"62","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"32"},"/home/padrino-eduardo/Desktop/webmga/src/index.js",[],["63","64"],"/home/padrino-eduardo/Desktop/webmga/src/App.js",[],"/home/padrino-eduardo/Desktop/webmga/src/Controller.js",["65"],"/home/padrino-eduardo/Desktop/webmga/src/View/Top.js",["66","67","68","69"],"\nimport { Header, Dropdown, FormGroup, Drawer, Nav, Navbar, Icon, Button, ButtonToolbar, Slider, Form, ControlLabel, Whisper, Tooltip, Divider } from 'rsuite';\nimport { ParameterSet } from './Tools';\nimport React from \"react\";\nimport View from './View';\nimport { render } from '@testing-library/react';\n\nclass ExportDropdown extends React.Component {\n\n    constructor(props) {\n        super();\n        this.dimensions = [1000, 1000];\n        this.f = props.f;\n        this.updateDimensions = this.updateDimensions.bind(this);\n        this.export = this.export.bind(this);\n    }\n\n    updateDimensions(val, index) {\n        this.dimensions[index] = parseInt(val);\n    }\n\n    export() {\n        this.f(...this.dimensions);\n    }\n\n    render() {\n        return (\n            <Dropdown title=\"Export\" trigger='click' placement=\"bottomEnd\" icon={<Icon icon=\"export\" />} >\n\n                <ParameterSet f={this.updateDimensions} titles={['Height', 'Width']} values={this.dimensions} step={5} positive\n                    styling={[\n                        { marginRight: 25 },\n                        { marginTop: 18, marginLeft: 35 }\n                    ]} />\n\n                <Button style={{ width: 180, marginLeft: 25, marginRight: 25, marginTop: 15, marginBottom: 15 }} appearance='primary' onClick={this.export}> Export </Button>\n            </Dropdown>);\n    }\n\n};\n\nclass SamplesDropdown extends React.Component {\n\n    constructor(props) {\n        super(props);\n        this.model = props.model;\n        this.state = { active: 2 };\n        this.f = props.f;\n\n        this.updateKey = this.updateKey.bind(this);\n    }\n\n    updateKey(val) {\n        this.setState({\n            active: val\n        });\n    }\n\n    render() {\n        const state = this.state;\n        return (\n            <Dropdown \n            title=\"Library\"\n            trigger='click'\n            placement=\"bottomEnd\"\n            icon={<Icon icon=\"database\" />}\n            appearance='subtle'\n            onSelect={(eventKey) => {\n                this.f(eventKey);\n\n            }}>\n                <Dropdown.Menu title=\"Samples\">\n                    <Dropdown.Item eventKey={1}>Unit Vector Orientations</Dropdown.Item>\n                    <Dropdown.Item eventKey={2}>Quaternion Orientations</Dropdown.Item>\n                </Dropdown.Menu>\n                <Dropdown.Menu title=\"Spherocylinders\">\n                    <Dropdown.Item eventKey={3}>SC4 Isotropic</Dropdown.Item>\n                    <Dropdown.Item eventKey={4}>SC4 Nematic</Dropdown.Item>\n                    <Dropdown.Item eventKey={5}>SC4 Smectic</Dropdown.Item>\n                </Dropdown.Menu>\n                <Dropdown.Menu title=\"Prolate and Oblate Ellipsoids\">\n                    <Dropdown.Item eventKey={6}>E5 Isotropic</Dropdown.Item>\n                    <Dropdown.Item eventKey={7}>E5 Nematic</Dropdown.Item>\n                    <Dropdown.Item eventKey={8}>O5 Isotropic</Dropdown.Item>\n                    <Dropdown.Item eventKey={9}>O5 Nematic</Dropdown.Item>\n                </Dropdown.Menu>\n                <Dropdown.Menu title=\"Dense Crystal Packings\">\n                    <Dropdown.Item eventKey={10}>Box Crystal (Small)</Dropdown.Item>\n                    <Dropdown.Item eventKey={11}>Box Crystal (Large)</Dropdown.Item>\n                </Dropdown.Menu>\n                <Dropdown.Menu title=\"Other\">\n                    <Dropdown.Item eventKey={12}>Fig1</Dropdown.Item>\n                    <Dropdown.Item eventKey={13}>HBC</Dropdown.Item>\n                </Dropdown.Menu>\n                \n                <Dropdown.Item panel style={{ padding: 5, width: 120 }}></Dropdown.Item>\n\n\n            </Dropdown>\n        );\n\n    }\n}\n\nclass PerformanceDropdown extends React.Component {\n\n    constructor(props) {\n        super(props);\n        this.model = props.model;\n        this.state = { val: props.model.lod + 1 };\n\n        this.updateVal = this.updateVal.bind(this);\n    }\n\n    updateVal(val) {\n        this.setState({\n            val: val\n        });\n    }\n\n    render() {\n        const lod = this.state.val;\n        return (\n            <Dropdown title=\"Performance\" trigger='click' placement=\"bottomEnd\" icon={<Icon icon=\"dashboard\" />}>\n                <Form style={{ marginLeft: 20, marginTop: 20 }} layout=\"inline\">\n                    <FormGroup>\n                        <ControlLabel>Level of Detail</ControlLabel>\n                        <Whisper placement=\"bottom\" trigger=\"hover\" speaker={\n                            <Tooltip>\n                                Decreasing LOD will increase rendering speed.\n                            </Tooltip>\n                        }>\n                            <Icon icon=\"question-circle\" size=\"lg\" />\n                        </Whisper>\n                    </FormGroup>\n                </Form>\n\n                <Slider\n                    min={1}\n                    step={1}\n                    max={5}\n                    value={lod}\n                    graduated\n                    progress\n                    style={{ width: 200, marginLeft: 30, marginRight: 30, marginBottom: 20 }}\n                    onChange={(value) => {\n                        this.model.updateLOD(value - 1);\n                        this.updateVal(value);\n                        this.model.update();\n                    }}\n\n                />\n                <br />\n            </Dropdown>\n        );\n    }\n\n}\n\nclass Top extends React.Component {\n\n    constructor(props) {\n        super(props);\n        this.model = props.model;\n        this.functions = props.functions;\n        this.toggler = props.toggler;\n        this.state = { fps: 0, showDrawer: false, rotating: false };\n        this.updateFPS = this.updateFPS.bind(this);\n        this.toggleDrawer = this.toggleDrawer.bind(this);\n        this.toggleAutorotate = this.toggleAutorotate.bind(this);\n\n        this.chronometer = props.chronometer;\n        this.chronometer.f = this.updateFPS;\n\n        this.toggler.autorotate = () => {\n            this.toggleAutorotate();\n        }\n    }\n\n    toggleAutorotate() {\n        this.setState({\n            rotating: !this.state.rotating\n        });\n        this.model.toggleAutorotate();\n        if (this.model.rotating) {\n            this.toggler.closeSidemenu();\n        }\n        this.continuousRender();\n    }\n\n    continuousRender = () => {\n        this.model.update();\n        this.chronometer.click();\n        this.model.controls.update();\n        if (this.model.rotating) {\n            requestAnimationFrame(this.continuousRender);\n        }\n    }\n\n    toggleDrawer() {\n        this.setState({\n            showDrawer: !this.state.showDrawer\n        });\n    }\n\n    updateFPS(fps) {\n        this.setState({\n            fps: fps.toFixed(2)\n        });\n    }\n\n    render() {\n        const fps = this.state.fps;\n        const showDrawer = this.state.showDrawer;\n        const rotating = this.state.rotating;\n        return (\n            <div>\n                <Header style={{ height: 56 }}>\n                    <Navbar>\n                        <Navbar.Body>\n                            <Nav pullRight >\n                                <ButtonToolbar>\n                                    <Nav.Item active>fps: {fps}</Nav.Item>\n                                    <Nav.Item active={rotating} onClick={this.toggleAutorotate} appearance=\"subtle\" icon={<Icon icon=\"refresh\" />}>Autorotate</Nav.Item>\n                                    <Nav.Item appearance=\"subtle\" disabled={true} icon={<Icon icon=\"info-circle\" />}>Manual</Nav.Item>\n                                    <Nav.Item onClick={this.toggleDrawer} appearance=\"subtle\" icon={<Icon icon=\"book\" />}>Notes</Nav.Item>\n                                    <PerformanceDropdown model={this.model} />\n                                    <SamplesDropdown f={this.functions[3]} />\n\n                                    <ExportDropdown f={this.functions[2]} />\n                                    <Nav.Item appearance=\"subtle\" icon={<Icon icon=\"file-download\" />} onSelect={this.functions[0]}>Save</Nav.Item>\n                                    <input type=\"file\"\n                                        id=\"upload-btn\"\n                                        style={{ display: 'none' }}\n                                        className='input-file'\n                                        accept='.json,.webmga'\n                                        onChange={e => this.functions[1](e.target.files[0])} />\n                                    <label for=\"upload-btn\">\n                                        <Nav.Item icon={<Icon icon=\"file-upload\" />}>Upload</Nav.Item>\n                                    </label>\n\n                                </ButtonToolbar>\n\n                            </Nav>\n                            <Nav pullLeft>\n                                <h6 style={{ padding: 20 }}> WebMGA</h6>\n                            </Nav>\n                        </Navbar.Body>\n                    </Navbar>\n                </Header>\n                <Drawer\n                    size={'xs'}\n                    placement={'right'}\n                    show={showDrawer}\n                    onHide={this.toggleDrawer}\n                    backdrop={false}\n                >\n                    <Drawer.Header>\n                        <Drawer.Title>Information About System</Drawer.Title>\n                    </Drawer.Header>\n                    <Drawer.Body>\n                        Coarse-grained modeling of molecular fluids is often based on non-spherical convex rigid bodies like ellipsoids or spherocylinders representing rodlike or platelike molecules or groups of atoms, with site-site interaction potentials depending both on the distance among the particles and the relative orientation. In this category of potentials, the Gay-Berne family has been studied most extensively.<br /><br />\n                     However, conventional molecular graphics programs are not designed to visualize such objects. Usually the basic units are atoms displayed as spheres, or as vertices in a graph. Atomic aggregates can be highlighted through an increasing amount of stylized representations, e.g., Richardson ribbon diagrams for the secondary structure of a protein, Connolly molecular surfaces, density maps, etc., but ellipsoids\n                     and spherocylinders are generally missing, especially as elementary simulation units. <br /><br /> We fill this gap providing and discussing a customized OpenGL-based program for the interactive, rendered representation of large ensembles of convex bodies, useful especially in liquid crystal research. We pay particular attention to the performance issues for typical system sizes in this feld. The code is distributed as open source.\n                    <br /><br />\n                        <a href=\"http://qmga.sourceforge.net/\" target=\"_blank\" rel=\"noopener noreferrer\">QMGA Homepage</a>\n                        <br /><br />\n                        <a href=\"https://pubs.acs.org/doi/10.1021/ct700192z\" target=\"_blank\" rel=\"noopener noreferrer\">DOI 10.1021/ct700192z</a>\n                    </Drawer.Body>\n                </Drawer>\n            </div>\n        );\n    }\n};\n\nexport default Top;","/home/padrino-eduardo/Desktop/webmga/src/View/Side.js",[],"/home/padrino-eduardo/Desktop/webmga/src/Model/Model.js",["70","71","72"],"import {\n    Scene,\n    WebGLRenderer,\n    PerspectiveCamera,\n    OrthographicCamera,\n    Vector3,\n    PlaneHelper,\n    Plane\n} from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport Set from './Set.js'\nimport Light from './Light.js'\nimport Tools from './Tools.js'\nimport { Alert } from 'rsuite';\n\nexport class Model {\n    sets = [];\n\n    scene;\n    camera;\n    lighting;\n    bgColour;\n    controls;\n    lookAt;\n    tools;\n    renderer;\n\n    height;\n    width;\n\n\n\n    gridEnabled = false;\n    axesEnabled = false;\n    boundingShapeEnabled = false;\n    sidebarExpanded = false;\n\n    cameraType = 'perspective';\n    cameraPosition;\n\n    selectedSet;\n\n    planeConstants;\n    clippingPlanes;\n    clippingHelpers;\n    clipIntersections;\n\n    constructor(chronometer) {\n        this.scene = new Scene();\n        this.chronometer = chronometer;\n        this.setDefault();\n    }\n\n    setDefault() {\n        this.rotating = false;\n        this.cameraPostion = null;\n        this.lightHelperWarningGiven = false;\n        this.selectedSet = 0;\n        this.initClippers();\n        this.renderer = new WebGLRenderer({ antialias: false, preserveDrawingBuffer: false, powerPreference: \"high-performance\" });\n        this.renderer.setPixelRatio(window.devicePixelRatio);\n        this.renderer.localClippingEnabled = true;\n\n        this.lookAt = new Vector3(0, 0, 0);\n\n        this.updateDimensions();\n        this.setCamera(this.cameraType);\n\n        this.lighting = [\n            new Light('ambient'),\n            new Light('directional'),\n            new Light('point')];\n\n        this.tools = new Tools(50, 0xffffff);\n        this.bgColour = \"#000000\";\n        this.renderer.setClearColor(this.bgColour);\n\n        for (let l of this.lighting) {\n            this.scene.add(l.light);\n        }\n        this.scene.add(this.camera);\n        this.lod = 1;\n    }\n\n    getData() {\n        let model = {};\n        let temp = {};\n        model.sets = [];\n        for (let set of this.sets) {\n            temp.name = set.name;\n            temp.orientationType = set.orientationType;\n            temp.positions = set.positions;\n            temp.orientations = set.orientations;\n            model.sets.push(temp);\n            temp = {};\n        }\n        return model;\n    }\n\n    update() {\n        this.renderer.render(this.scene, this.camera);\n        if (!this.rotating) {\n            this.chronometer.click();\n        }\n    }\n\n    initClippers() {\n        this.clippingIntersections = false;\n\n        this.clippingPlanes = [\n            new Plane(new Vector3(1, 0, 0), 50),\n            new Plane(new Vector3(-1, 0, 0), 50),\n            new Plane(new Vector3(0, 1, 0), 50),\n            new Plane(new Vector3(0, -1, 0), 50),\n            new Plane(new Vector3(0, 0, 1), 50),\n            new Plane(new Vector3(0, 0, -1), 50)\n        ];\n\n        this.clippingHelpers = [\n            new PlaneHelper(this.clippingPlanes[0], 100, 0xff0000),\n            new PlaneHelper(this.clippingPlanes[1], 100, 0xff0000),\n            new PlaneHelper(this.clippingPlanes[2], 100, 0x00ff00),\n            new PlaneHelper(this.clippingPlanes[3], 100, 0x00ff00),\n            new PlaneHelper(this.clippingPlanes[4], 100, 0x0000ff),\n            new PlaneHelper(this.clippingPlanes[5], 100, 0x0000ff)\n        ];\n\n        for (let helper of this.clippingHelpers) {\n            helper.visible = false;\n            this.scene.add(helper);\n        }\n    }\n\n    toggleClipIntersection(toggle) {\n        for (let set of this.sets) {\n            set.toggleClipIntersection(toggle);\n        }\n    }\n\n    toggleHelper(i, toggle) {\n        this.clippingHelpers[2 * i].visible = toggle;\n        this.clippingHelpers[2 * i + 1].visible = toggle;\n    }\n\n    updateSlicer(i, vals) {\n        for (let set of this.sets) {\n            set.updateSlicers(i, vals);\n        }\n    }\n\n    updateDimensions() {\n        this.height = (window.innerHeight - 56);\n\n        if (this.sidebarExpanded) {\n            this.width = window.innerWidth - 356;\n        } else {\n            this.width = window.innerWidth - 56;\n        }\n        this.renderer.setSize(this.width, this.height);\n    }\n\n    setCamera(type) {\n        this.cameraType = type;\n\n        if (type === 'perspective') {\n            this.camera = new PerspectiveCamera(50, this.width / this.height, 0.1, 1000);\n        } else {\n            this.camera = new OrthographicCamera(this.width / -2, this.width / 2, this.height / 2, this.height / -2, -100, 5000);\n        }\n\n        if (this.cameraPosition != null) {\n            this.camera.position.set(...this.cameraPosition);\n        }\n\n        this.controls = new OrbitControls(this.camera, this.renderer.domElement);\n        this.controls.target = this.lookAt;\n        this.update();\n    }\n\n    updateCamera() {\n        if (this.cameraType === 'perspective') {\n            this.camera.aspect = this.width / this.height;\n        } else {\n            this.camera.left = this.width / - 2;\n            this.camera.right = this.width / 2;\n            this.camera.top = this.height / 2;\n            this.camera.bottom = this.height / - 2;\n        }\n        this.camera.updateProjectionMatrix();\n        this.update();\n    }\n\n    updateCameraZoom(val) {\n        this.camera.zoom = val;\n        this.camera.updateProjectionMatrix();\n    }\n\n    updateCameraPosition(p) {\n        let x = p.r * Math.sin(p.psi) * Math.cos(p.theta);\n        let y = p.r * Math.sin(p.psi) * Math.sin(p.theta);\n        let z = p.r * Math.cos(p.psi);\n        this.cameraPosition = [x, y, z];\n        this.camera.position.set(x, y, z);\n        this.controls.update();\n    }\n\n    updateLookAt(l) {\n        this.lookAt = new Vector3(l.x, l.y, l.z);\n        this.controls.target = this.lookAt;\n        this.controls.update();\n\n    }\n\n    toggleSidebar() {\n        this.sidebarExpanded = !this.sidebarExpanded;\n        this.updateDimensions();\n        this.updateCamera();\n    }\n\n    updateBg(colour) {\n        this.bgColour = Model.rgbToHex(colour.r, colour.g, colour.b);\n        this.renderer.setClearColor(this.bgColour);\n    }\n\n    toggleLight(type, enabled) {\n        this.lighting[type].visible = enabled;\n    }\n\n    updateLight(type, colour) {\n        this.lighting[type].updateColour(Model.rgbToHex(colour.r, colour.g, colour.b), colour.i);\n        if (type != 0) {\n            this.lighting[type].helper.update();\n        }\n    }\n\n    toggleLightHelper(type, toggle) {\n        if (toggle) {\n            if (this.bgColour == '#ffffff' && !this.lightHelperWarningGiven) {\n                Alert.warning('If the background colour and light colour are the same, the light helper may not be visible.');\n                this.lightHelperWarningGiven = true;\n            }\n            this.lighting[type].helper.update();\n            this.scene.add(this.lighting[type].helper);\n        } else {\n            this.scene.remove(this.lighting[type].helper);\n        }\n    }\n\n    updateLightPosition(type, pos) {\n        this.lighting[type].updatePosition(pos.x, pos.y, pos.z);\n        this.lighting[type].helper.update();\n    }\n\n    updateReferenceColour(rgb) {\n        let passGrid = false;\n        let passAxes = false;\n        let passShape = false;\n        if (this.gridEnabled) {\n            this.toggleGrid();\n            passGrid = true;\n        }\n        if (this.axesEnabled && !this.tools.multicolour) {\n            this.toggleAxes();\n            passAxes = true;\n        }\n        if (this.boundingShapeEnabled) {\n            this.updateBoundingShape('', false);\n            passShape = true;\n        }\n        this.tools.updateColour(Model.rgbToHex(rgb.r, rgb.g, rgb.b));\n        if (passGrid) {\n            this.toggleGrid();\n        }\n        if (passAxes) {\n            this.toggleAxes();\n        }\n        if (passShape) {\n            this.updateBoundingShape(this.tools.boundingShapeType, true);\n            passShape = true;\n        }\n    }\n\n    toggleAxesMulticolour(){\n        let passAxes = false;\n        if (this.axesEnabled) {\n            this.toggleAxes();\n            passAxes = true;\n        }\n        this.tools.toggleMulticolour();\n        if (passAxes) {\n            this.toggleAxes();\n        }\n    }\n\n    updateGridSize(size) {\n        let passGrid = false;\n        let passAxes = false;\n        if (this.gridEnabled) {\n            this.toggleGrid();\n            passGrid = true;\n        }\n        if (this.axesEnabled) {\n            this.toggleAxes();\n            passAxes = true;\n        }\n\n        this.tools.updateSize(size);\n\n        if (passGrid) {\n            this.toggleGrid();\n        }\n        if (passAxes) {\n            this.toggleAxes();\n        }\n    }\n\n\n    toggleGrid() {\n        this.gridEnabled = !this.gridEnabled;\n\n        if (this.gridEnabled) {\n            this.scene.add(this.tools.subGrid);\n        } else {\n            this.scene.remove(this.tools.subGrid);\n        }\n    }\n\n    toggleAxes() {\n        this.axesEnabled = !this.axesEnabled;\n\n        if (this.axesEnabled) {\n            for (let a of this.tools.axes) {\n                this.scene.add(a);\n            }\n        } else {\n            for (let a of this.tools.axes) {\n                this.scene.remove(a);\n            }\n        }\n\n\n    }\n\n    toggleAutorotate() {\n        this.controls.autoRotate = !this.controls.autoRotate;\n        this.rotating = !this.rotating;\n    }\n\n    static rgbToHex(r, g, b) {\n        function componentToHex(c) {\n            var hex = c.toString(16);\n            return hex.length === 1 ? \"0\" + hex : hex;\n        }\n        return \"#\" + componentToHex(r) + componentToHex(g) + componentToHex(b);\n    }\n\n    updateBoundingShape(type, enabled) {\n        this.boundingShapeEnabled = enabled;\n        this.scene.remove(this.tools.boundingShape);\n        if (enabled) {\n            this.scene.add(this.tools.genBoundingShape(type, this.sets));\n        }\n    }\n\n\n    getParameters(val) {\n        return Set.getParameters(val);\n    }\n\n    updateModel(id, params, f) {\n        for (const m of this.sets[id].meshes) {\n            this.scene.remove(m);\n        }\n        f(...params);\n        for (const m of this.sets[id].meshes) {\n            this.scene.add(m);\n        }\n    }\n\n    getLOD() {\n        return this.lod;\n    }\n\n    updateLOD(val) {\n        this.lod = val;\n        for (let i = 0; i < this.sets.length; i++) {\n            this.updateModel(i, [i, val], (i, val) => {\n                this.sets[i].lod = val;\n                this.sets[i].meshes = [];\n                this.sets[i].genGeometries();\n                this.sets[i].setElements();\n                this.sets[i].genMeshes();\n            });\n        }\n    }\n\n    updateUserColour(id, colour) {\n        this.updateModel(id, [id, colour], (id, colour) => {\n            this.sets[id].meshes = [];\n            this.sets[id].setUserColour(Model.rgbToHex(colour.r, colour.g, colour.b));\n            this.sets[id].genMeshes();\n        });\n    }\n\n    updateShape(id, shape, parameters) {\n        this.updateModel(id, [id, shape, parameters], (id, shape, parameters) => {\n            this.sets[id].meshes = [];\n            this.sets[id].shapeType = shape;\n            this.sets[id].parameters = parameters.vals;\n            this.sets[id].genGeometries();\n            this.sets[id].setElements();\n            this.sets[id].genMeshes();\n        });\n    }\n\n\n    toggleWireframe(id, toggle) {\n        this.updateModel(id, [id, toggle], (id, toggle) => {\n            this.sets[id].meshes = [];\n            this.sets[id].wireframe = toggle;\n            this.sets[id].genMeshes();\n        });\n    }\n\n    toggleUserColour(id, toggle) {\n        this.updateModel(id, [id, toggle], (id, toggle) => {\n            this.sets[id].meshes = [];\n            this.sets[id].colourByDirector = toggle;\n            this.sets[id].genMeshes();\n        });\n    }\n\n    genSets(sets) {\n        for (let set of this.sets) {\n            for (const m of set.meshes) {\n                this.scene.remove(m);\n            }\n        }\n        this.sets = [];\n        for (let setData of sets) {\n            this.sets.push(new Set(setData, this.clippingPlanes, this.clippingIntersections));\n        }\n        for (let set of this.sets) {\n            for (const m of set.meshes) {\n                this.scene.add(m);\n            }\n        }\n    }\n\n\n    //used for qmga conversion\n    load(data) {\n        let particleSets = data.split(\"$\");\n        let setData, ps;\n        for (let particleSet of particleSets) {\n            if (particleSet == \"\") {\n                return;\n            }\n            else {\n                setData = particleSet.split(\"\\n\");\n                ps = new Set(setData[0], setData[1], setData.slice(2), this.clippingPlanes, this.clippingIntersections);\n                this.sets.push(ps);\n            }\n        }\n\n\n        for (let set of this.sets) {\n            for (const m of set.meshes) {\n                this.scene.add(m);\n            }\n        }\n    }\n\n}\n\nexport default Model;\n","/home/padrino-eduardo/Desktop/webmga/src/Model/Light.js",[],"/home/padrino-eduardo/Desktop/webmga/src/View/SubMenus.js",["73","74","75","76","77"],"\nimport { Nav, Divider, Checkbox, FormGroup, RadioGroup, Radio, Grid, Row, Col, Alert, Whisper, Tooltip, Icon } from 'rsuite';\nimport React from \"react\";\nimport { SliceSlider, ParameterInput, ParameterSet, CustomSlider } from './Tools'\nimport View from './View'\n\nconst TITLE_LEFT_MARGIN = 30;\nconst dividerStyle = {\n    color: '#A4A9A3'\n}\nconst submenuParameterSetStyling = [\n    { width: 130, marginLeft: 10 },\n    { marginTop: 10, marginLeft: 30 }\n];\nexport class ModelsOptions extends React.Component {\n\n    constructor(props) {\n        super();\n        this.state = View.state.model;\n        this.model = props.model;\n\n        this.selectShape = this.selectShape.bind(this);\n        this.selectSet = this.selectSet.bind(this);\n        this.updateParameter = this.updateParameter.bind(this);\n        this.toggleWireframe = this.toggleWireframe.bind(this);\n        this.toggleColour = this.toggleColour.bind(this);\n        this.updateUserColour = this.updateUserColour.bind(this);\n    }\n\n\n    updateUserColour(value, type) {\n        let colour = this.state.configurations[this.state.active].colour;\n\n        switch (type) {\n            case 'r':\n                colour.r = value;\n                break;\n            case 'g':\n                colour.g = value;\n                break;\n            case 'b':\n                colour.b = value;\n                break;\n            default:\n                Alert.error('Error: Unexpected RGB Identifier');\n        }\n        this.model.updateUserColour(this.state.active, colour);\n        this.model.update();\n        View.state.model.configurations[this.state.active].colour = colour;\n    }\n\n    toggleColour() {\n        let toggle = !this.state.configurations[this.state.active].colourFromDirector;\n        this.setState({\n            colourFromDirector: toggle\n        });\n        View.state.model.configurations[this.state.active].colourFromDirector = toggle;\n        this.model.toggleUserColour(this.state.active, toggle);\n        this.model.update();\n    }\n\n    toggleWireframe() {\n        let toggle = !this.state.configurations[this.state.active].displayAsWireframe;\n        this.setState({\n            displayAsWireframe: toggle\n        });\n        View.state.model.configurations[this.state.active].displayAsWireframe = toggle;\n        this.model.toggleWireframe(this.state.active, toggle);\n        this.model.update();\n    }\n\n    updateParameter(val, index) {\n        let parameter = parseFloat(val);\n\n        let globalState = View.state.model.configurations[this.state.active];\n        globalState.parameters.vals[index] = parameter;\n\n        let configs = this.state.configurations;\n        configs[this.state.active].parameters.vals[index] = parameter;\n\n        this.setState({\n            configurations: configs\n        });\n\n        this.model.updateShape(this.state.active, globalState.shape, globalState.parameters);\n        this.model.update();\n        this.reset();\n    }\n\n    reset() {\n        let i;\n        if (this.state.reset > 50) {\n            i = 0;\n        } else {\n            i = this.state.reset;\n        }\n        this.setState(\n            {\n                reset: ++i\n            }\n        );\n    }\n\n    selectSet(val) {\n        for (let i = 0; i < this.state.sets.length; i++) {\n            if (this.state.sets[i].localeCompare(val) === 0) {\n                this.setState({\n                    active: i\n                })\n                View.state.model.active = i;\n                break;\n            }\n        }\n        this.reset();\n    }\n\n    selectShape(val) {\n        let parameters = this.model.getParameters(val);\n        this.setState(\n            {\n                shape: val,\n                parameters: parameters\n            }\n        );\n        this.reset();\n        View.state.model.configurations[this.state.active].shape = val;\n        View.state.model.configurations[this.state.active].parameters = parameters;\n        this.model.updateShape(this.state.active, val, parameters);\n        this.model.update();\n    }\n\n    render() {\n        const configState = this.state.configurations[this.state.active];\n        const reset = this.state.reset;\n        const title = configState.title;\n        const shapes = [\"Ellipsoid\", \"Sphere\", \"Spherocylinder\", \"Spheroplatelet\", \"Cut Sphere\", \"Cylinder\", \"Torus\"];\n        const sets = this.state.sets;\n\n        return (\n            <div key={reset}>\n\n\n                <Divider><strong style={dividerStyle}> Configuration</strong></Divider>\n                <ParameterInput f={this.selectSet} selectingSet title=\"Set\" values={sets} active={title} styling={submenuParameterSetStyling} />\n                <ParameterInput f={this.selectShape} title=\"Shape\" values={shapes} active={configState.shape} styling={submenuParameterSetStyling} />\n                <ParameterSet f={this.updateParameter} titles={configState.parameters.names} values={configState.parameters.vals} step={0.1} positive styling={submenuParameterSetStyling} />\n                <br />\n                <Divider><strong style={dividerStyle}>  Material </strong></Divider>\n\n                <Row className=\"show-grid\">\n                    <Col xs={1} />\n                    <Col xs={20}>\n                        <Checkbox checked={configState.displayAsWireframe} onClick={this.toggleWireframe}> Display as Wireframe </Checkbox>\n                        <Checkbox checked={configState.colourFromDirector} onClick={this.toggleColour}> Colour from Director </Checkbox>\n                        <br />\n                    </Col>\n                </Row>\n\n                <p style={{ marginLeft: TITLE_LEFT_MARGIN }}> RGB </p>\n                <CustomSlider f={this.updateUserColour} disabled={configState.colourFromDirector} boundaries={[0, 255]} val={configState.colour.r} type={'r'} />\n                <CustomSlider f={this.updateUserColour} disabled={configState.colourFromDirector} boundaries={[0, 255]} val={configState.colour.g} type={'g'} />\n                <CustomSlider f={this.updateUserColour} disabled={configState.colourFromDirector} boundaries={[0, 255]} val={configState.colour.b} type={'b'} />\n            </div>\n        );\n    }\n}\n\nexport class CameraOptions extends React.Component {\n\n    constructor(props) {\n        super();\n        this.state = View.state.camera;\n        this.model = props.model;\n        this.selectType = this.selectType.bind(this);\n        this.updateLookat = this.updateLookat.bind(this);\n        this.updatePosition = this.updatePosition.bind(this);\n        this.updateZoom = this.updateZoom.bind(this);\n    }\n\n    updateZoom(value) {\n        this.setState({\n            zoom: value\n        });\n        this.model.updateCameraZoom(value);\n        this.model.update();\n        View.state.camera.zoom = value;\n    }\n    selectType(value) {\n        this.setState({\n            type: value\n        });\n        View.state.camera.type = value;\n        this.model.setCamera(value);\n        if (value == \"orthographic\") {\n            this.updateZoom(50);\n\n        } else {\n            this.updateZoom(1);\n        }\n        \n    }\n\n    updatePosition(value, type) {\n        let position = this.state.position;\n\n        if (value != NaN && value != null) {\n            switch (type) {\n                case 0:\n                    position.r = parseFloat(value);\n                    break;\n                case 1:\n                    position.theta = parseFloat(value);\n                    break;\n                case 2:\n                    position.psi = parseFloat(value);\n                    break;\n                default:\n                    Alert.error('Error: Unexpected Camera Position Input');\n                    return;\n            }\n        }\n\n        this.model.updateCameraPosition(position);\n        this.model.update();\n        View.state.camera.position = position;\n    }\n\n    updateLookat(value, type) {\n        let lookAt = this.state.lookAt;\n\n        if (value != NaN && value != null) {\n            switch (type) {\n                case 0:\n                    lookAt.x = parseFloat(value);\n                    break;\n                case 1:\n                    lookAt.y = parseFloat(value);\n                    break;\n                case 2:\n                    lookAt.z = parseFloat(value);\n                    break;\n                default:\n                    Alert.error('Error: Unexpected Look At Input');\n                    return;\n            }\n        }\n\n        this.model.updateLookAt(lookAt);\n        this.model.update();\n        View.state.camera.lookAt = lookAt;\n    }\n\n\n    render() {\n        const cameraType = this.state.type;\n        const zoom = this.state.zoom;\n        const lookAt = [this.state.lookAt.x, this.state.lookAt.y, this.state.lookAt.z];\n        const cameraPosition = [this.state.position.r, this.state.position.theta, this.state.position.psi];\n\n\n        return (\n            <div>\n               \n                <Row className=\"show-grid\">\n                    <Col xs={2} />\n                    <Col xs={12}>\n\n                        <FormGroup controlId=\"radioList\">\n                            <RadioGroup name=\"radioList\" value={cameraType} onChange={this.selectType}>\n                                <p><b>Type</b></p>\n                                <Radio value=\"perspective\">Perspective </Radio>\n                                <Radio value=\"orthographic\">Orthographic </Radio>\n                            </RadioGroup>\n                        </FormGroup>\n\n                    </Col>\n                </Row>\n              \n                <Grid fluid>\n\n                    <Row className=\"show-grid\">\n                        <Col xs={2} />\n                        <Col xs={12}>\n                            <br />\n                            <p><b> Position</b></p>\n                        </Col>\n                    </Row>\n                    <ParameterSet titles={[\"r\", \"theta\", \"psi\"]} values={cameraPosition} f={this.updatePosition} step={0.5} styling={submenuParameterSetStyling} />\n                    <Row className=\"show-grid\">\n                        <Col xs={2} />\n                        <Col xs={12}>\n                            <br />\n                            <p><b> Zoom </b></p>\n                        </Col>\n                    </Row>\n                    <CustomSlider key={cameraType} boundaries={[1, 100]} val={zoom} f={this.updateZoom} />\n                    <Row className=\"show-grid\">\n                        <Col xs={2} />\n                        <Col xs={12}>\n                            <br />\n                            <p><b> Look at</b></p>\n                        </Col>\n                    </Row>\n                    <ParameterSet titles={[\"x\", \"y\", \"z\"]} values={lookAt} f={this.updateLookat} step={0.5} styling={submenuParameterSetStyling} />\n\n                </Grid>\n                <br />\n\n\n\n            </div>);\n    }\n}\n\nexport class SlicingOptions extends React.Component {\n\n    constructor(props) {\n        super();\n        this.state = View.state.slicing;\n        this.model = props.model;\n\n        this.toggleIntersection = this.toggleIntersection.bind(this);\n        this.toggleHelperX = this.toggleHelperX.bind(this);\n        this.toggleHelperY = this.toggleHelperY.bind(this);\n        this.toggleHelperZ = this.toggleHelperZ.bind(this);\n        this.updateHelpers = this.updateHelpers.bind(this);\n        this.updateSlicer = this.updateSlicer.bind(this);\n    }\n\n    toggleIntersection() {\n        let toggle = !this.state.clipIntersection;\n        this.setState(\n            {\n                clipIntersection: toggle\n            }\n        );\n        View.state.slicing.clipIntersection = toggle;\n        this.model.toggleClipIntersection(toggle);\n        this.model.update();\n    }\n\n    updateHelpers(helpers) {\n        this.setState(\n            {\n                helpers: helpers\n            }\n        );\n        View.state.slicing.helpers = helpers;\n    }\n\n    toggleHelperX() {\n        let helpers = this.state.helpers;\n        let toggle = !helpers[0];\n        helpers[0] = toggle;\n        this.updateHelpers(helpers);\n        this.model.toggleHelper(0, toggle);\n        this.model.update();\n    }\n\n    toggleHelperY() {\n        let helpers = this.state.helpers;\n        let toggle = !helpers[1];\n        helpers[1] = toggle;\n        this.updateHelpers(helpers);\n        this.model.toggleHelper(1, toggle);\n        this.model.update();\n    }\n\n    toggleHelperZ() {\n        let helpers = this.state.helpers;\n        let toggle = !helpers[2];\n        helpers[2] = toggle;\n        this.updateHelpers(helpers);\n        this.model.toggleHelper(2, toggle);\n        this.model.update();\n    }\n\n    updateSlicer(i, vals) {\n        switch (i) {\n            case 0:\n                View.state.slicing.x = vals;\n                break;\n            case 1:\n                View.state.slicing.y = vals;\n                break;\n            case 2:\n                View.state.slicing.z = vals;\n                break;\n            default:\n                Alert.error('Error: Unexpected Slicing Identifier');\n        }\n\n        this.model.updateSlicer(i, vals);\n        this.model.update();\n    }\n    render() {\n        const state = this.state;\n        return (\n            <div>\n                <br />\n                <Grid fluid>\n                    <Row className=\"show-grid\">\n                        <Col xs={1} />\n                        <Col xs={20}>\n                            <Checkbox disabled={true} checked={state.clipIntersection} onClick={this.toggleIntersection}> Slice Intersection</Checkbox>\n                        </Col>\n                    </Row>\n                </Grid>\n                {/* TO DO */}\n                <SliceSlider title=\"X : \" f={this.updateSlicer} index={0} vals={state.x} />\n                <br />\n                <Grid fluid>\n                    <Row className=\"show-grid\">\n                        <Col xs={1} />\n                        <Col xs={12}>\n                            <Checkbox checked={state.helpers[0]} onClick={this.toggleHelperX}> Show Helper</Checkbox>\n                        </Col>\n                    </Row>\n                </Grid>\n                <SliceSlider title=\"Y : \" f={this.updateSlicer} index={1} vals={state.y} />\n                <br />\n                <Grid fluid>\n                    <Row className=\"show-grid\">\n                        <Col xs={1} />\n                        <Col xs={12}>\n                            <Checkbox checked={state.helpers[1]} onClick={this.toggleHelperY}> Show Helper</Checkbox>\n                        </Col>\n                    </Row>\n                </Grid>\n                <SliceSlider title=\"Z : \" f={this.updateSlicer} index={2} vals={state.z} />\n                <br />\n                <Grid fluid>\n                    <Row className=\"show-grid\">\n                        <Col xs={1} />\n                        <Col xs={12}>\n                            <Checkbox checked={state.helpers[2]} onClick={this.toggleHelperZ}> Show Helper</Checkbox>\n                        </Col>\n                    </Row>\n                </Grid>\n            </div>\n        );\n    }\n\n}\n\nexport const AdditionalLightsNav = ({ active, onSelect }) => {\n    return (\n        <Nav activeKey={active} onSelect={onSelect} style={{ margin: 10, width: 280 }} justified appearance=\"tabs\">\n            <Nav.Item eventKey=\"point\">Point</Nav.Item>\n            <Nav.Item eventKey=\"directional\">Directional</Nav.Item>\n        </Nav>\n    );\n};\n\nexport class AdditionalLightOptions extends React.Component {\n\n    constructor(props) {\n        super();\n        this.state = View.state.pointLight;\n        this.model = props.model;\n        this.reset = 0;\n        this.handleSelect = this.handleSelect.bind(this);\n        this.updateColour = this.updateColour.bind(this);\n        this.updatePosition = this.updatePosition.bind(this);\n        this.toggleLightEnabled = this.toggleLightEnabled.bind(this);\n        this.toggleHelper = this.toggleHelper.bind(this);\n\n    }\n    handleSelect() {\n        if (this.state.active.localeCompare('point') === 0) {\n            this.setState(View.state.directionalLight);\n        } else {\n            this.setState(View.state.pointLight);\n        }\n        if (this.reset > 5) {\n            this.reset = 0;\n        }\n\n        this.setState({ reset: ++this.reset });\n    }\n\n    toggleHelper() {\n        let helper = !this.state.helper;\n        this.setState({\n            helper: helper\n        });\n\n        if (this.state.active.localeCompare('point') === 0) {\n            View.state.pointLight.helper = helper;\n            this.model.toggleLightHelper(2, helper);\n            this.model.update();\n        } else {\n            View.state.directionalLight.helper = helper;\n            this.model.toggleLightHelper(1, helper);\n            this.model.update();\n        }\n    }\n\n    toggleLightEnabled() {\n        let enabled = !this.state.enabled;\n        this.setState({\n            enabled: enabled\n        });\n        let intensity;\n        if (this.state.active.localeCompare('point') === 0) {\n            View.state.pointLight.enabled = enabled;\n            intensity = View.state.pointLight.colour.i;\n        } else {\n            View.state.directionalLight.enabled = enabled;\n            intensity = View.state.directionalLight.colour.i;\n        }\n\n        if (enabled) {\n            this.updateColour(intensity, 'i');\n        } else {\n            this.updateColour(0, 'i');\n        }\n        this.setState({ reset: ++this.reset });\n\n        if (this.state.active.localeCompare('point') === 0) {\n            View.state.pointLight.colour.i = intensity;\n        } else {\n            View.state.directionalLight.colour.i = intensity;\n        }\n    }\n\n    updateColour(value, type) {\n        let colour = this.state.colour;\n\n        switch (type) {\n            case 'r':\n                colour.r = value;\n                break;\n            case 'g':\n                colour.g = value;\n                break;\n            case 'b':\n                colour.b = value;\n                break;\n            case 'i':\n                colour.i = value;\n                break;\n            default:\n                Alert.error('Error: Unexpected RGB Identifier');\n        }\n\n        if (this.state.active.localeCompare('point') === 0) {\n            this.model.updateLight(2, colour);\n            View.state.pointLight.colour = colour;\n        } else {\n            this.model.updateLight(1, colour);\n            View.state.directionalLight.colour = colour;\n        }\n        this.model.update();\n    }\n    updatePosition(value, type) {\n        let position = this.state.position;\n\n        switch (type) {\n            case 'x':\n                position.x = value;\n                break;\n            case 'y':\n                position.y = value;\n                break;\n            case 'z':\n                position.z = value;\n                break;\n            default:\n                Alert.error('Error: Unexpected Position Identifier');\n        }\n\n        if (this.state.active.localeCompare('point') === 0) {\n            this.model.updateLightPosition(2, position);\n            View.state.pointLight.position = position;\n        } else {\n            this.model.updateLightPosition(1, position);\n            View.state.directionalLight.position = position;\n        }\n        this.model.update();\n    }\n\n    render() {\n        const active = this.state.active;\n        const lightState = this.state;\n        return (\n            <div key={lightState.reset}>\n                <br />\n                <AdditionalLightsNav active={active} onSelect={this.handleSelect} />\n                <br />\n                <Grid fluid>\n                    <Row className=\"show-grid\">\n                        <Col xs={1} />\n                        <Col xs={12}>\n                            <Checkbox checked={lightState.enabled} onClick={this.toggleLightEnabled}> <strong>Enabled </strong> </Checkbox>\n                            <Checkbox checked={lightState.helper} onClick={this.toggleHelper}> <strong>Show Helper </strong> </Checkbox>\n                            <br />\n                        </Col>\n                    </Row>\n                </Grid>\n                <p style={{ marginLeft: TITLE_LEFT_MARGIN }}> RGB </p>\n                <CustomSlider disabled={!lightState.enabled} boundaries={[0, 255]} val={lightState.colour.r} f={this.updateColour} type={'r'} />\n                <CustomSlider disabled={!lightState.enabled} boundaries={[0, 255]} val={lightState.colour.g} f={this.updateColour} type={'g'} />\n                <CustomSlider disabled={!lightState.enabled} boundaries={[0, 255]} val={lightState.colour.b} f={this.updateColour} type={'b'} />\n                <p style={{ marginLeft: TITLE_LEFT_MARGIN }}> Intensity </p>\n                <CustomSlider disabled={!lightState.enabled} boundaries={[0, 100]} val={lightState.colour.i} f={this.updateColour} type={'i'} />\n                <p style={{ marginLeft: TITLE_LEFT_MARGIN }}> Position XYZ </p>\n                <CustomSlider disabled={!lightState.enabled} boundaries={[-50, 50]} val={lightState.position.x} f={this.updatePosition} type={'x'} />\n                <CustomSlider disabled={!lightState.enabled} boundaries={[-50, 50]} val={lightState.position.y} f={this.updatePosition} type={'y'} />\n                <CustomSlider disabled={!lightState.enabled} boundaries={[-50, 50]} val={lightState.position.z} f={this.updatePosition} type={'z'} />\n            </div>\n        );\n    }\n}\n\nexport class AmbientLightOptions extends React.Component {\n    constructor(props) {\n        super();\n\n        this.state = View.state.ambientLight;\n\n        this.model = props.model;\n\n        this.updateAmbientLightColour = this.updateAmbientLightColour.bind(this);\n        this.updateBackgroundColour = this.updateBackgroundColour.bind(this);\n    }\n    updateAmbientLightColour(value, type) {\n        let colour = this.state.ambientLightColour;\n\n        switch (type) {\n            case 'r':\n                colour.r = value;\n                break;\n            case 'g':\n                colour.g = value;\n                break;\n            case 'b':\n                colour.b = value;\n                break;\n            case 'i':\n                colour.i = value;\n                break;\n            default:\n                Alert.error('Error: Unexpected RGB Identifier');\n        }\n        this.model.updateLight(0, colour);\n        this.model.update();\n        View.state.ambientLight.ambientLightColour = colour;\n    }\n    updateBackgroundColour(value, type) {\n        let colour = this.state.backgroundColour;\n\n        switch (type) {\n            case 'r':\n                colour.r = value;\n                break;\n            case 'g':\n                colour.g = value;\n                break;\n            case 'b':\n                colour.b = value;\n                break;\n            default:\n                Alert.error('Error: Unexpected RGB Identifier');\n        }\n        this.model.updateBg(colour);\n        this.model.update();\n        View.state.ambientLight.backgroundColour = colour;\n    }\n    render() {\n        const ambientLightColour = this.state.ambientLightColour;\n        const backgroundColour = this.state.backgroundColour;\n        return (\n            <div>\n                <Divider><strong style={dividerStyle}> Ambient Light </strong></Divider>\n                <p style={{ marginLeft: TITLE_LEFT_MARGIN }}> RGB </p>\n                <CustomSlider disabled={false} boundaries={[0, 255]} val={ambientLightColour.r} f={this.updateAmbientLightColour} type={'r'} />\n                <CustomSlider disabled={false} boundaries={[0, 255]} val={ambientLightColour.g} f={this.updateAmbientLightColour} type={'g'} />\n                <CustomSlider disabled={false} boundaries={[0, 255]} val={ambientLightColour.b} f={this.updateAmbientLightColour} type={'b'} />\n                <p style={{ marginLeft: TITLE_LEFT_MARGIN }}> Intensity </p>\n                <CustomSlider disabled={false} boundaries={[0, 100]} val={ambientLightColour.i} f={this.updateAmbientLightColour} type={'i'} />\n                <Divider><strong style={dividerStyle}> Background Colour</strong></Divider>\n                <p style={{ marginLeft: TITLE_LEFT_MARGIN }}> RGB </p>\n                <CustomSlider disabled={false} boundaries={[0, 255]} val={backgroundColour.r} f={this.updateBackgroundColour} type={'r'} />\n                <CustomSlider disabled={false} boundaries={[0, 255]} val={backgroundColour.g} f={this.updateBackgroundColour} type={'g'} />\n                <CustomSlider disabled={false} boundaries={[0, 255]} val={backgroundColour.b} f={this.updateBackgroundColour} type={'b'} />\n            </div>\n        );\n    }\n}\n\nexport class ReferenceOptions extends React.Component {\n    constructor(props) {\n        super();\n        this.state = View.state.reference;\n\n        this.model = props.model;\n        this.toggleBoundingShapeEnabled = this.toggleBoundingShapeEnabled.bind(this);\n        this.selectShape = this.selectShape.bind(this);\n        this.toggleAxes = this.toggleAxes.bind(this);\n        this.toggleGrid = this.toggleGrid.bind(this);\n        this.updateColour = this.updateColour.bind(this);\n        this.updateGridSize = this.updateGridSize.bind(this);\n        this.toggleMulticolour = this.toggleMulticolour.bind(this);\n\n    }\n    updateColour(value, type) {\n        let rgb = this.state.gridColour;\n\n        switch (type) {\n            case 'r':\n                rgb.r = value;\n                break;\n            case 'g':\n                rgb.g = value;\n                break;\n            case 'b':\n                rgb.b = value;\n                break;\n            default:\n                Alert.error('Error: Unexpected RGB Identifier');\n        }\n        this.model.updateReferenceColour(rgb);\n        this.model.update();\n        View.state.reference.gridColour = rgb;\n    }\n    updateGridSize(value) {\n        this.model.updateGridSize(value);\n        this.model.update();\n        View.state.reference.size = value;\n    }\n    toggleBoundingShapeEnabled() {\n        let toggle = !View.state.reference.boundingShapeEnabled;\n        this.setState({\n            boundingShapeEnabled: toggle\n        });\n        View.state.reference.boundingShapeEnabled = toggle;\n        this.model.updateBoundingShape(this.state.activeShape, toggle);\n        this.model.update();\n    }\n    selectShape(value) {\n        this.setState({\n            activeShape: value\n        });\n        View.state.reference.activeShape = value;\n        this.model.updateBoundingShape(value, this.state.boundingShapeEnabled);\n        this.model.update();\n    }\n    toggleMulticolour() {\n        this.setState({\n            multicolour: !this.state.multicolour\n        });\n        this.model.toggleAxesMulticolour();\n        this.model.update();\n        View.state.reference.multicolour = !View.state.reference.multicolour;\n    }\n    toggleAxes() {\n        this.setState({\n            showAxes: !this.state.showAxes\n        });\n        this.model.toggleAxes();\n        this.model.update();\n        View.state.reference.showAxes = !View.state.reference.showAxes;\n    }\n    toggleGrid() {\n        this.setState({\n            showGrid: !this.state.showGrid\n        });\n        this.model.toggleGrid();\n        this.model.update();\n        View.state.reference.showGrid = !View.state.reference.showGrid;\n    }\n\n    render() {\n        const enabled = this.state.boundingShapeEnabled;\n        const activeShape = this.state.activeShape;\n        const showAxes = this.state.showAxes;\n        const showGrid = this.state.showGrid;\n        const colour = this.state.gridColour;\n        const size = this.state.size;\n        const multicolour = this.state.multicolour;\n        return (\n            <div>\n\n                <Grid fluid>\n                    <Row className=\"show-grid\">\n                        <Col xs={2} />\n                        <Col xs={12}>\n                            <br />\n                            <p><b> Bounding Shape </b></p>\n                        </Col>\n                    </Row>\n                    <Row className=\"show-grid\">\n                        <Col xs={1} />\n                        <Col xs={12}>\n                            <Checkbox style={{ marginLeft: 12 }} checked={enabled} onClick={this.toggleBoundingShapeEnabled}>  Show </Checkbox>\n                        </Col>\n                    </Row>\n                    <Row className=\"show-grid\">\n                        <Col xs={3} />\n                        <Col xs={12}>\n                            <FormGroup controlId=\"radioList\">\n                                <RadioGroup name=\"radioList\" value={activeShape} onChange={this.selectShape}>\n                                    <Radio disabled={!enabled} value=\"box\"  >Box </Radio>\n                                    <Radio disabled={!enabled} value=\"sphere\" >Sphere </Radio>\n                                    {/* TO DO CYLINDER */}\n                                    <Radio disabled={true} value=\"cylinder\" >Cylinder </Radio>\n\n                                </RadioGroup>\n                            </FormGroup>\n                        </Col>\n                    </Row>\n                    <Row className=\"show-grid\">\n                        <Col xs={2} />\n                        <Col xs={12}>\n                            <br />\n                            <p><b> Axes </b></p>\n                        </Col>\n                    </Row>\n                    <Row className=\"show-grid\">\n                        <Col xs={1} />\n                        <Col xs={12}>\n                            <Checkbox style={{ marginLeft: 12 }} checked={showAxes} onClick={this.toggleAxes}> Show</Checkbox>\n\n                        </Col>\n                    </Row>\n\n                    <Row className=\"show-grid\">\n                        <Col xs={1} />\n                        <Col xs={12}>\n\n                            <Checkbox style={{ marginLeft: 12 }} checked={multicolour} onClick={this.toggleMulticolour}> Multi-Colour</Checkbox>\n\n\n                        </Col>\n                        <Col xs={4}>\n                            <Whisper placement=\"bottom\" trigger=\"hover\" speaker={\n                                <Tooltip>\n                                    X : RED <br /> Y : GREEN <br /> Z : BLUE\n                            </Tooltip>\n                            }>\n                                <Icon style={{marginTop: 8}}icon=\"question-circle\" size=\"lg\" />\n                            </Whisper>\n                        </Col>\n                    </Row>\n\n\n\n\n                    <Row className=\"show-grid\">\n                        <Col xs={2} />\n                        <Col xs={12}>\n                            <br />\n                            <p><b> Grid </b></p>\n                        </Col>\n                    </Row>\n                    <Row className=\"show-grid\">\n                        <Col xs={1} />\n                        <Col xs={12}>\n                            <Checkbox style={{ marginLeft: 12 }} checked={showGrid} onClick={this.toggleGrid}> Show</Checkbox>\n                        </Col>\n                    </Row>\n                </Grid>\n                <br />\n\n                <p style={{ marginLeft: TITLE_LEFT_MARGIN }}> Size </p>\n                <CustomSlider disabled={false} boundaries={[0, 100]} val={size} f={this.updateGridSize} />\n                <p style={{ marginLeft: TITLE_LEFT_MARGIN }}> RGB </p>\n                <CustomSlider disabled={false} boundaries={[0, 255]} val={colour.r} f={this.updateColour} type={'r'} />\n                <CustomSlider disabled={false} boundaries={[0, 255]} val={colour.g} f={this.updateColour} type={'g'} />\n                <CustomSlider disabled={false} boundaries={[0, 255]} val={colour.b} f={this.updateColour} type={'b'} />\n\n\n                <br />\n            </div>\n        );\n    }\n}","/home/padrino-eduardo/Desktop/webmga/src/Model/Shapes.js",[],"/home/padrino-eduardo/Desktop/webmga/src/View/Tools.js",[],"/home/padrino-eduardo/Desktop/webmga/src/View/View.js",[],"/home/padrino-eduardo/Desktop/webmga/src/Model/Set.js",["78","79","80","81","82","83","84","85","86","87","88","89"],"import {\n    Mesh,\n    MeshLambertMaterial,\n    Vector3,\n    Quaternion,\n    Euler,\n    Color,\n    DoubleSide,\n\n} from 'three';\nimport {eigs} from 'mathjs';\nimport * as SHAPE from './Shapes.js';\nimport Model from './Model';\nimport Parameters from './Parameters';\nimport { Alert } from 'rsuite';\nimport colourMap from './ColourMap.json';\n\nexport class Set {\n    name;\n    shapeType;\n    parameters;\n    shape;\n    orientationType;\n    wireframe;\n    userColour;\n    colourByDirector;\n    lod;\n    clippingPlanes;\n    clipIntersection;\n    colourMap;\n\n    positions = [];\n    orientations = [];\n    elements = []\n    meshes = [];\n\n    constructor(data, cp, ci) {\n        this.name = data.name;\n        this.orientationType = data.orientationType;\n        this.positions = data.positions;\n        this.orientations = data.orientations;\n        this.clippingPlanes = cp;\n        this.clipIntersection = ci;\n\n        this.setDefaults();\n\n        if (data.shapeType != null) {\n            this.shapeType = data.shapeType;\n        }\n        if (data.parameters != null) {\n            this.shapeType = data.parameters;\n        }\n        if (this.name == null) {\n            this.name = this.shapeType;\n        }\n\n        this.validateData();\n        this.genGeometries();\n        this.genElements();\n        this.setElements();\n        this.genMeshes();\n    }\n\n    //deprecated\n    // constructor(name, orientationType, data, cp, ci) {\n    //     this.name = name;\n    //     this.orientationType = orientationType;\n\n    //     this.clippingPlanes = cp;\n    //     this.clipIntersection = ci;\n\n    //     this.setDefaults();\n    //     this.genGeometries();\n    //     this.genElementsDeprecated(data);\n    //     this.setElements();\n    //     this.genMeshes();\n\n    // }\n\n    validateData() {\n        if (this.positions.length !== this.orientations.length) {\n            throw 'Error: Position data does not correspond to orientation data. \\n Total positions: ' + this.positions.length + '\\n Total rotations: ' + this.orientations.length;\n        }\n\n        for (let p in this.parameters) {\n            if (p < 0) {\n                throw 'Error: Invalid parameter ' + p.toString() + ' for ' + this.name + '\\n Must be positive.';\n            }\n        }\n\n        let defaultParameters = Set.getParameters(this.shapeType);\n        if (this.parameters.length != defaultParameters.vals.length) {\n            throw 'Error: Wrong number of parameters specified for ' + this.name + '. \\n Required: ' + defaultParameters.names;\n        }\n    }\n\n    setDefaults() {\n        this.userColour = new Color(\"#FFFFFF\");\n        this.colourByDirector = true;\n        this.wireframe = true;\n        this.lod = 1;\n        this.shapeType = 'Ellipsoid';\n        this.parameters = Parameters.Ellipsoid.vals;\n    }\n\n    updateSlicers(i, vals) {\n        this.clippingPlanes[2 * i + 1].constant = vals[1];\n        this.clippingPlanes[2 * i].constant = -vals[0];\n    }\n\n    toggleClipIntersection(toggle) {\n        this.clipIntersection = toggle;\n        for (let mesh of this.meshes) {\n            mesh.material.clipIntersection = toggle;\n        }\n    }\n\n    genMeshes() {\n        let m;\n        let c;\n        let mat;\n\n        for (let elem of this.elements) {\n            if (this.colourByDirector) {\n                let rgb = colourMap.values[elem.colourIndex];\n                c = new Color(Model.rgbToHex(...rgb));\n            } else {\n                c = this.userColour;\n            }\n\n            mat = new MeshLambertMaterial({\n                color: c,\n                clippingPlanes: this.clippingPlanes,\n                clipIntersection: this.clipIntersection\n            });\n            mat.wireframe = this.wireframe;\n\n            for (let g of elem.geometries) {\n                m = new Mesh(g, mat);\n                this.meshes.push(m);\n            }\n        }\n    }\n\n    setElements() {\n        let geoms = [];\n\n        for (let elem of this.elements) {\n            if (this.shape.isPreset) {\n                geoms.push(this.shape.presetGeometry.clone());\n            }\n            else {\n                geoms.push(this.shape.stripGeometry.clone());\n                geoms.push(this.shape.fanGeometries[0].clone());\n                geoms.push(this.shape.fanGeometries[1].clone());\n            }\n\n            this.rotate(elem.euler, geoms);\n            this.translate(elem.position, geoms);\n            \n            elem.setGeometries(geoms);\n\n            geoms = [];\n        }\n    }\n\n    genElements() {\n        for (let i = 0; i < this.positions.length; i++) {\n            this.elements.push(new this.Element(this.positions[i], this.getRotations(this.orientationType, this.orientations[i])));\n        }\n        this.calculateDirector();\n        for(let elem of this.elements){\n            elem.setColourIndex(this.calculateColourIndex(elem));\n        }\n    }\n\n    genElementsDeprecated(elements) {\n        let position, orientation, attributes, euler, nP;\n        let temp = [], colour = [];\n\n        for (let elem of elements) {\n\n            if (elem === \"\") {\n                return;\n            }\n\n            attributes = elem.split(\" \");\n\n            for (let a of attributes) {\n                temp.push(parseFloat(a));\n            }\n\n            attributes = temp;\n            temp = [];\n\n            if (attributes.length !== 6) { break; }\n\n            position = attributes.slice(0, 3);\n            orientation = attributes.slice(3);\n\n            console.log(position);\n            console.log(orientation);\n\n            this.positions.push(position);\n            this.orientations.push(orientation);\n\n            euler = this.getRotations(this.orientationType, orientation);\n            colour = this.colourFromOrientation(euler);\n\n            nP = new this.Element(colour, position, euler);\n            this.elements.push(nP);\n        }\n    }\n\n    genGeometries() {\n        switch (this.shapeType) {\n            case 'Ellipsoid':\n                this.shape = new SHAPE.Ellipsoid(...this.parameters);\n                break;\n            case 'Spherocylinder':\n                this.shape = new SHAPE.Spherocylinder(...this.parameters);\n                break;\n            case 'Spheroplatelet':\n                this.shape = new SHAPE.Spheroplatelet(...this.parameters);\n                break;\n            case 'Cut Sphere':\n                this.shape = new SHAPE.CutSphere(...this.parameters);\n                break;\n            case 'Sphere':\n                this.shape = new SHAPE.Preset('Sphere', this.parameters);\n                break;\n            case 'Cylinder':\n                this.shape = new SHAPE.Preset('Cylinder', this.parameters);\n                break;\n            case 'Torus':\n                this.shape = new SHAPE.Preset('Torus', this.parameters);\n                break;\n            default:\n                throw 'Error: unexpected shape identifier. \\n Found: ' + this.shapeType;\n        }\n\n        this.shape.LOD = this.lod;\n        this.shape.generate();\n    }\n\n    translate(pos, geoms) {\n        console.log(pos);\n        for (let g of geoms) {\n            g.translate(pos[0], pos[1], pos[2]);\n        }\n    }\n\n    rotate(e, geoms) {\n        for (let g of geoms) {\n            g.rotateX(e.x);\n            g.rotateY(e.y);\n            g.rotateZ(e.z);\n        }\n    }\n\n    getRotations(type, rot) {\n        let q = new Quaternion();\n        switch (type) {\n            case 'v':\n                let defaultVector = new Vector3(0, 0, 1);\n                q.setFromUnitVectors(defaultVector, new Vector3(rot[0], rot[1], rot[2]));\n                break;\n            case 'q':\n                q.set(rot[1], rot[2], rot[3], rot[0]);\n                break;\n            case 'a':\n                q.setFromAxisAngle(new Vector3(rot[0], rot[1], rot[2]), rot[3]);\n                break;\n            case 'e':\n                let e = new Euler();\n                e.fromArray(rot);\n                q.setFromEuler(e)\n                break;\n            default:\n                throw 'Error: Unexpected rotation type value. \\n Found: ' + type + '\\n Expected: v | q | a | e';\n        }\n\n        return q;\n\n    }\n\n    colourFromOrientation(euler) {\n        let colour = [];\n\n        colour.push(Math.round((euler._x + Math.PI) / (2 * Math.PI) * (255)));\n        colour.push(Math.round((euler._y + Math.PI) / (2 * Math.PI) * (255)));\n        colour.push(Math.round((euler._z + Math.PI) / (2 * Math.PI) * (255)));\n\n        return colour;\n    }\n\n    calculateDirector() {\n        let n = this.elements.length;\n\n        if (this.elements.length == 0) {\n            Alert.error('Error: No elements in set, director calculation failed.');\n            return;\n        }\n\n        let orderTensor = [[0,0,0],[0,0,0],[0,0,0]];\n        //let eigenvectorsInColumns = new Matrix3();\n\n        let factor = 3 / (2 * n);\n        let constant = 0.5;\n\n        let orientation;\n\n        // loop over all molecules and calculate order tensor\n        for (let i = 0; i < n; ++i) {\n            orientation = this.elements[i].orientation;\n            orderTensor[0][0] += orientation[0]**2;\n            orderTensor[0][1] += orientation[0]*orientation[1];\n            orderTensor[0][2] += orientation[0]*orientation[2];\n            orderTensor[1][1] += orientation[1]**2;\n            orderTensor[1][2] += orientation[1]*orientation[2];\n            orderTensor[2][2] += orientation[2]**2;\n        }\n\n        // multiply each tensor value with \"factor\" and afterwards subtract \"subtract\" from diagonal elements\n        orderTensor[0][0] *= factor; orderTensor[0][0] -= constant;\n        orderTensor[0][1] *= factor;\n        orderTensor[0][2] *= factor;\n        orderTensor[1][1] *= factor; orderTensor[1][1] -= constant;\n        orderTensor[1][2] *= factor;\n        orderTensor[2][2] *= factor; orderTensor[2][2] -= constant;\n\n        // mirror matrix to make it symmetric\n        orderTensor[1][0] = orderTensor[0][1];\n        orderTensor[2][0] = orderTensor[0][2];\n        orderTensor[2][1] = orderTensor[1][2];\n\n        let eigen = eigs(orderTensor);\n        \n        //returns index of max eigenvalue\n        let index = eigen.values.reduce((iMax, x, i, arr) => x > arr[iMax] ? i : iMax, 0);\n\n        this.director = eigen.vectors[index];\n\n        let norm = Math.sqrt(this.director[0]**2 + this.director[1]**2 + this.director[2]**2);\n\n        if (norm == 0 || norm == NaN || norm == undefined){\n            this.director = [0,0,1];\n        }else{\n            this.director[0] /= norm;\n            this.director[1] /= norm;\n            this.director[2] /= norm;\n        }\n\n        // TEST!\n    }\n\n    calculateColourIndex(element){\n        let n = colourMap.values.length - 1;\n\n        let scalarProduct = Math.abs(element.orientation[0] * this.director[0]\n            + element.orientation[1] * this.director[1]\n            + element.orientation[2] * this.director[2]);\n\n        if (scalarProduct > 1){scalarProduct = 1;}\n\n        return Math.round(Math.acos( scalarProduct )/Math.PI*2*( n ));;\n    }\n\n    setUserColour(hex) {\n        this.userColour = new Color(hex);\n    }\n\n    static getParameters(val) {\n        let parameters;\n\n        switch (val) {\n            case 'Ellipsoid':\n                parameters = Parameters.Ellipsoid;\n                break;\n            case 'Spherocylinder':\n                parameters = Parameters.Spherocylinder;\n                break;\n            case 'Spheroplatelet':\n                parameters = Parameters.Spheroplatelet;\n                break;\n            case 'Cut Sphere':\n                parameters = Parameters.CutSphere;\n                break;\n            case 'Sphere':\n                parameters = Parameters.Sphere;\n                break;\n            case 'Cylinder':\n                parameters = Parameters.Cylinder;\n                break;\n            case 'Torus':\n                parameters = Parameters.Torus;\n                break;\n            default:\n                Alert.error('Error: Unexpected shape identifier');\n        }\n\n        return parameters;\n    }\n\n    Element = class Element {\n        geometries;\n        orientation;\n        position;\n        colourIndex;\n        euler;\n\n        constructor(p, q) {\n            this.position = p;\n            this.orientation = this.quaternionToUnitVector(q);\n\n            this.euler = new Euler();\n            this.euler.setFromQuaternion(q);\n            this.colourIndex = 0;\n        }\n\n        quaternionToUnitVector(q){\n            let a = (2 * (   q.w*q.y + q.x*q.z ));\n            let b = (2 * ( - q.w*q.x + q.y*q.z ));\n            let c = (1 - 2 * ( q.x**2 + q.y**2 ));\n            return [a,b,c];\n        }\n\n        setColourIndex(i){\n            this.colourIndex = i;\n        }\n\n        getColour() {\n            return Model.rgbToHex(this.colour[0], this.colour[1], this.colour[2]);\n        }\n\n        setGeometries(geoms) {\n            this.geometries = geoms;\n        }\n\n    }\n}\n\nexport default Set;","/home/padrino-eduardo/Desktop/webmga/src/Model/Parameters.js",[],"/home/padrino-eduardo/Desktop/webmga/src/Model/Tools.js",[],{"ruleId":"90","replacedBy":"91"},{"ruleId":"92","replacedBy":"93"},{"ruleId":"94","severity":1,"message":"95","line":287,"column":21,"nodeType":"96","messageId":"97","endLine":287,"endColumn":23},{"ruleId":"98","severity":1,"message":"99","line":2,"column":135,"nodeType":"100","messageId":"101","endLine":2,"endColumn":142},{"ruleId":"98","severity":1,"message":"102","line":5,"column":8,"nodeType":"100","messageId":"101","endLine":5,"endColumn":12},{"ruleId":"98","severity":1,"message":"103","line":6,"column":10,"nodeType":"100","messageId":"101","endLine":6,"endColumn":16},{"ruleId":"98","severity":1,"message":"104","line":60,"column":15,"nodeType":"100","messageId":"101","endLine":60,"endColumn":20},{"ruleId":"94","severity":1,"message":"105","line":231,"column":18,"nodeType":"96","messageId":"97","endLine":231,"endColumn":20},{"ruleId":"94","severity":1,"message":"95","line":238,"column":31,"nodeType":"96","messageId":"97","endLine":238,"endColumn":33},{"ruleId":"94","severity":1,"message":"95","line":456,"column":29,"nodeType":"96","messageId":"97","endLine":456,"endColumn":31},{"ruleId":"94","severity":1,"message":"95","line":194,"column":19,"nodeType":"96","messageId":"97","endLine":194,"endColumn":21},{"ruleId":"106","severity":1,"message":"107","line":206,"column":13,"nodeType":"96","messageId":"108","endLine":206,"endColumn":25},{"ruleId":"94","severity":1,"message":"105","line":206,"column":19,"nodeType":"96","messageId":"97","endLine":206,"endColumn":21},{"ruleId":"106","severity":1,"message":"107","line":231,"column":13,"nodeType":"96","messageId":"108","endLine":231,"endColumn":25},{"ruleId":"94","severity":1,"message":"105","line":231,"column":19,"nodeType":"96","messageId":"97","endLine":231,"endColumn":21},{"ruleId":"98","severity":1,"message":"109","line":8,"column":5,"nodeType":"100","messageId":"101","endLine":8,"endColumn":15},{"ruleId":"110","severity":1,"message":"111","line":82,"column":13,"nodeType":"112","messageId":"113","endLine":82,"endColumn":180},{"ruleId":"110","severity":1,"message":"111","line":87,"column":17,"nodeType":"112","messageId":"113","endLine":87,"endColumn":113},{"ruleId":"94","severity":1,"message":"105","line":92,"column":36,"nodeType":"96","messageId":"97","endLine":92,"endColumn":38},{"ruleId":"110","severity":1,"message":"111","line":93,"column":13,"nodeType":"112","messageId":"113","endLine":93,"endColumn":128},{"ruleId":"110","severity":1,"message":"111","line":239,"column":17,"nodeType":"112","messageId":"113","endLine":239,"endColumn":89},{"ruleId":"110","severity":1,"message":"111","line":280,"column":17,"nodeType":"112","messageId":"113","endLine":280,"endColumn":113},{"ruleId":"94","severity":1,"message":"95","line":300,"column":34,"nodeType":"96","messageId":"97","endLine":300,"endColumn":36},{"ruleId":"94","severity":1,"message":"95","line":346,"column":18,"nodeType":"96","messageId":"97","endLine":346,"endColumn":20},{"ruleId":"106","severity":1,"message":"107","line":346,"column":26,"nodeType":"96","messageId":"108","endLine":346,"endColumn":37},{"ruleId":"94","severity":1,"message":"95","line":346,"column":31,"nodeType":"96","messageId":"97","endLine":346,"endColumn":33},{"ruleId":"94","severity":1,"message":"95","line":346,"column":46,"nodeType":"96","messageId":"97","endLine":346,"endColumn":48},"no-native-reassign",["114"],"no-negated-in-lhs",["115"],"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","no-unused-vars","'Divider' is defined but never used.","Identifier","unusedVar","'View' is defined but never used.","'render' is defined but never used.","'state' is assigned a value but never used.","Expected '!==' and instead saw '!='.","use-isnan","Use the isNaN function to compare with NaN.","comparisonWithNaN","'DoubleSide' is defined but never used.","no-throw-literal","Expected an error object to be thrown.","ThrowStatement","object","no-global-assign","no-unsafe-negation"]